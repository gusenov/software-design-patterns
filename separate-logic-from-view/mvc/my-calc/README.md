# Калькулятор на MVC

Cуть подобных приемов в том чтобы обеспечить слабое связывание.
При слабом связывании можно один компонент легко заменить другим.
При сильном нельзя.
Слабое связывание достигается за счет того, что сущности одеваются в интерфейсы.
Т.е. взаимодействует не содержание с содержанием, а форма с формой. Что позволяет менять содержание.
Почти любую проблему в программировании можно решить добавлением уровня косвенности.
Если компонент заменяем, то тогда все в порядке.

# Обмен информацией

MVC - это все про обмен информацией.
Объекты обмениваются информацией.

Источник событий и потребитель событий части одного целого:

```
producer.GenerateConsumer();
consumer.GenerateProducer();
```

Эти функции могут быть фабричными и создавать нужного подписчика или производителя.

Подписчика лучше создавать как отдельный вспомогательный объект, который знает о времени жизни производителя.
Например, производитель возвращает объект ```Subscriber``` и при его конструировании передает в него ссылку на себя чтобы подписчик на своей деструкции мог отписаться от получения событий.

Вопрос кто для кого является consumer-ом а кто producer-ом.

```
controller
view = controller'            // controller.GenerateProducer(), View является поставщиком событий для контроллера
model = view' = controller''  // view.GenerateProducer(), Model, является поставщиком событий для View
```

```
model
view = model'                 // View произвели от модели.
controller = view' = model''  // От View произвели контроллер.
```

```
controller
view = controller'  // Контроллер может создавать разные View.
viewmodel = view'   // А View генерировать ViewModel-и под своё представление.
model = viewmodel'  // Далее этой ViewModel-ью можно обернуть уже настоящую модель. Связать ее с ней. Получается ViewModel это своего рода абстракция реальной модели. Как в MVVM.
```

Model поставляет события для ViewModel.
ViewModel поставляет события для View.
View поставляет события для Controller.

## Модель ```Number```

Один из принципов ООП - данные и их обработку хранить в одном месте.
Поэтому сложение чисел должно поддерживать классом ```Number```. 
Т.е. это не просто ```GetValue()``` и ```SetValue()```.
Например, для ```Number``` должен быть переопределен оператор ```+```.
Не следует в контроллере складывать числа.

Также модель должна позволять подписываться на изменения:

```
Number.OnChange = { // do something; };
```

У модели нет поставщика событий. 
Она ни от кого ничего не потребляет. 
Она сама является производителем событий.

# Контроллер ```Controller``` или ```Manager```

Контроллер реагирует на UI.

```
Controller::Controller() 
{
    // Варианты:
    view.SetObserver(controller);
    view.SetReactor(controller);
    view.SetDelegate(controller);
    view.SetListener(controller);
    view.SetHandler();
    view.SetOnClick = {};
    //

    this->num.OnChange = {
        view.SetDisplayValue(this->num);
    }
}
```

Лучше избегать конкретики связанной с определенным представлением.
Сегодня там есть кнопка плюс, завтра будет что-нибудь другое.
Вместо

```
Controller::OnPlusClick(e) {
    this->num.add(e.GetValue());
}
```

лучше

```
Controller::OnAddtionOperation(e) {
    this->num.add(e.GetValue());
}
```

# Представление

- ```MainView``` | ```RootView```
   - ```DisplayView```
   - ```NumberView```
   - ```OperationsView```
